import pandas as pd
import numpy as np
import random


class Die:
    """[A die has N sides, or “faces”, and W weights, and can be rolled to select a face.]
    """



    def __init__(self, faces):
        """[Takes an array of faces as an argument. The array's data type (dtype) may be strings or numbers.
            Internally iInitializes the weights to 1.0 for each face.
            Saves both faces and weights into a private dataframe that is to be shared by the other methods.]

        Args:
            faces ([type]): [this is the face of the die]
        """

        self.faces = faces

        self._dice_df = pd.DataFrame()
        self._dice_df = self._dice_df.assign(die_faces = self.faces)
        self._dice_df = self._dice_df.assign(die_weight = 1)  


    def change_weight(self, face, new_weight):
        """[Takes two arguments: the face value to be changed and the new weight.
            Checks to see if the face passed is valid; is it in the array of weights?
            Checks to see if the weight is valid; is it a float? Can it be converted to one?

        Args:
            face ([string or float or int]): [this is the face of the die]
            new_weight ([float]): [this is the value that determines the probablity of the face coming up]
        """
        
        if face in self._dice_df.die_faces.values:

            if type(new_weight) == float or type(new_weight) == int:

                index_of_face = self._dice_df[self._dice_df['die_faces'] == face].index[0]


                self._dice_df.loc[index_of_face, 'die_weight'] = new_weight


            else:
    
                try:

                    float(self.new_weight)
                    index_of_face = self._dice_df[self._dice_df['die_faces'] == face].index[0]
                    self._dice_df.loc[index_of_face, 'die_weight'] = new_weight

                except:

                    print("Not a float")


        else:
            print("Not a current dice face")

        
    
    def roll_die(self, roll = 1):
        """[Takes a parameter of how many times the die is to be rolled; defaults to 1. 
            This is essentially a random sample from the vector of faces according to the weights.
            Returns a list of outcomes.
            Does not store internally these results.]

        Args:
            roll (int, optional): [the number of times the die is rolled]. Defaults to 1.

        Returns:
            [list]: [list of values generated by rolling the dice]
        """
        
        
        total_weight = self._dice_df['die_weight'].sum()

        probabilities = self._dice_df['die_weight'].div(total_weight)

        return random.choices(self._dice_df['die_faces'], weights = probabilities, k = roll)


    def show_die(self):
        """[Returns the dataframe created in the initialiser. This helps the user keep track of changes]

        Returns:
            [dataframe]: [This is the die that the program currently uses]
        """

        return self._dice_df



class Game:
    """[A game consists of rolling of one or more dice of the same kind one or more times. 
        Each game is initialised with one or more of similarly defined dice (Die objects).
        By “same kind” and “similarly defined” we mean that each die in a given game has the same number of sides and associated faces, but each die object may have its own weights.
        The class has a behavior to play a game, i.e. to rolls all of the dice a given number of times.
        The class keeps the results of its most recent play. ]
    """

    def __init__(self, dices):
        """[Takes a single parameter, a list of already instantiated similar Die objects. This intialises the previously created die into a set. ]

        Args:
            dices ([list]): [list of already instatniated die objects]
        """

        self.dices = dices

    def play(self, num_rolls):
        """[Takes a single parameter, a list of already instantiated similar Die objects.]

        Args:
            num_rolls ([int]): [This is how many times the dice will be rolled]
        """

        self._rolls_results = pd.DataFrame()

        indexs = 0
        for die in self.dices:
            
            dice_rolls = die.roll_die(num_rolls)

            self._rolls_results[indexs] = dice_rolls

            indexs = indexs + 1

    def show_recent(self, wide = True):
        """[shows the user the results of the most recent play.
            This method just passes the private dataframe to the user.
            Takes a parameter to return the dataframe in narrow or wide form.
            This parameter defaults to wide form.
            This parameter should raise an exception of the user passes an invalid option.
            The narrow form of the dataframe will have a two-column index with the roll number and the die number, and a column for the face rolled.
            The wide form of the dataframe will a single column index with the roll number, and each die number as a column.]

        Args:
            wide (bool, optional): [This defines the organisation of the dataframe. The wide format has each die as its own column]. Defaults to True.

        Returns:
            [dataframe]: [This is the result of the game played]
        """

        if wide == True:
            return self._rolls_results

        else:
            
            return self._rolls_results.stack()

    
class Analyser:
    """[An analyzer takes the results of a single game and computes various descriptive statistical properties about it. These properties results are available as attributes of an Analyzer object.]
    """
    
    def __init__(self, game):
        """[Takes the game object and intialises]

        Args:
            game ([type]): [from the Game class this is the resulted die rolls]
        """

        self._result = game.show_recent()

    def jackpot(self):
        """[method to compute how many times the game resulted in all faces being identical.]

        Returns:
            [int]: [This is the amount of times the user hit the jackpot (all dice roll same value)]
        """

         list_bool = self._result.eq(self._result.iloc[:, 0], axis=0).all(1)
         return sum(list_bool)

    def combo(self):
        """[method to compute the distinct combinations of faces rolled, along with their counts]

        Returns:
            [dataframe]: [Returns updated dataframe with combinations rolled and sorts them by frequency]
        """

        return self._result.apply(lambda x: pd.Series(sorted(x)), 1).value_counts().to_frame('combo_n')


    def face_counts(self):
        """[method to compute how many times a given face is rolled in each event]

        Returns:
            [dataframe]: [has an index of the roll number and face values as columns]
        """
        
        facecount = _result.apply(pd.Series.value_counts, axis=1).fillna(0)
        return facecount

    


            


            
    












    











    